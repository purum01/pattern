<link href="card.css" rel="stylesheet">
<style>
  table {
    width: 80%;
    margin: 40px auto;
    border-collapse: collapse;
    font-family: 'Arial', sans-serif;
    font-size: 16px;
  }
  th, td {
    padding: 12px 20px;
    border-bottom: 1px solid #ddd;
    text-align: left;
  }
  th {
    background-color: #f9fafb;
    font-weight: bold;
  }
  tr:hover {
    background-color: #f1f5f9;
  }
</style>
<div class="card">
  <h1>Decorator Pattern</h1>
  <p>
    "객체에 추가 책임(responsibility)을 동적으로 부여할 수 있다.
서브클래싱(상속)을 통하지 않고도 기능을 확장할 수 있는 유연한 대안(Alternative)을 제공한다."
  </p>

  <div class="info">
    <div class="info-row">
      <div class="info-title">설명</div>
      <div class="info-content">
        상위 클래스 → 알고리즘 구조(템플릿) 제공 <br>
        하위 클래스 → 세부 단계(구현 내용)만 변경 <br>
        알고리즘 전체 흐름은 변하지 않고, 일부 세부 로직만 확장하는 패턴
      </div>
    </div>
  </div>
</div>  

<h3>🔵 데커레이터 패턴을 사용하는 이유</h3>
    <table>
      <thead>
        <tr>
          <th>이유</th>
          <th>설명</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>알고리즘의 구조를 재사용</td>
          <td>공통된 알고리즘의 흐름을 상위 클래스에 정의해 놓으면, 하위 클래스는 필요한 부분만 변경하면 된다.</td>
        </tr>
        <tr>
          <td>코드 중복 제거</td>
          <td>반복되는 알고리즘 구조를 하나로 통합하고, 세부 단계만 하위 클래스에서 다르게 구현할 수 있다.</td>
        </tr>
        <tr>
          <td>알고리즘의 변경 용이</td>
          <td>알고리즘 전체 뼈대가 한 곳(상위 클래스)에 있으므로 수정이나 확장이 쉽다.</td>
        </tr>
        <tr>
          <td>프레임워크나 라이브러리의 유연한 확장</td>
          <td>프레임워크는 템플릿 메서드를 제공하고, 사용자는 필요한 부분만 오버라이딩해서 커스터마이즈할 수 있다.</td>
        </tr>

      </tbody>
    </table>    
    
<h3>🟠 데커레이터 패턴의 활용 사례</h3>
<table>
  <thead>
    <tr>
      <th>활용 분야</th>
      <th>구체적 설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>데이터 처리 프로그램</td>
      <td>데이터 읽기 → 처리 → 저장 단계의 골격은 같고, 세부 처리 로직만 다를 때</td>
    </tr>
    <tr>
      <td>웹 프레임워크</td>
      <td>예를 들면 Spring MVC의 DispatcherServlet이 요청 처리 흐름(템플릿)을 제공하고, 세부 핸들러(Controller)는 개발자가 구현</td>
    </tr>
    <tr>
      <td>게임 개발</td>
      <td>게임의 초기화, 실행, 종료 순서는 같지만, 각각 다른 게임 장르에 따라 세부 내용이 다를 때</td>
    </tr>
    <tr>
      <td>테스트 케이스 작성</td>
      <td>테스트 준비 → 실행 → 결과 검증 순서는 동일하고, 실제 테스트 데이터나 로직만 다를 때</td>
    </tr>
    <tr>
      <td>UI 컴포넌트 생성</td>
      <td>공통된 UI 생성 흐름은 유지하되, 버튼이나 레이아웃 세부 구현만 달라질 때</td>
    </tr>
  
  </tbody>
</table>