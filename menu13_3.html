<h1 style="text-align: center;">리플렉션 기반의 동적 프록시 </h1>
<div style="border-left: 5px solid #4CAF50; background-color: #f9f9f9; padding: 20px 30px; border-radius: 10px; font-family: 'Segoe UI', sans-serif; line-height: 1.7; color: #1a1a1a; max-width: 800px;">
    <ul style="padding-left: 20px; margin: 0;">
      <li style="margin-bottom: 16px;">
        기존 코드에서는 <strong style="color: #d32f2f;">프록시 클래스마다 모든 메서드를 일일이 구현해야 하는 문제</strong>가 있음<br>
        <span style="color: #555;">→ 클래스가 많아질수록 유지보수와 코드 중복이 증가</span>
      </li>
  
      <li style="margin-bottom: 16px;">
        이를 해결하기 위해 <strong>Java의 동적 프록시 (<em>Dynamic Proxy</em>)</strong>를 사용할 수 있음<br>
        <span style="color: #555;">→ <strong style="color: #1976d2;">리플렉션</strong>을 이용해 실행 중에 프록시 객체를 <strong>동적으로 생성</strong></span><br>
        <span style="color: #555;">→ 원본 객체를 감싸고 공통 기능 (예: <span style="color: #43a047;">성능 측정</span>)을 주입 가능</span>
      </li>
  
      <li>
        예시로 등장하는 <code style="background-color: #eee; padding: 2px 6px; border-radius: 4px;">MetricsCollectorProxy</code>는<br>
        통계 수집 기능을 수행하는 <strong>동적 프록시 클래스</strong>
      </li>
    </ul>
  </div>

<pre><code id="source-code" class="language-java">
    public class MetricsCollectorProxy {
        private MetricsCollector metricsCollector;
    
        public MetricsCollectorProxy() {
            this.metricsCollector = new MetricsCollector();
        }
    
        public Object createProxy(Object proxiedObject) {
            Class<?>[] interfaces = proxiedObject.getClass().getInterfaces();
            DynamicProxyHandler handler = new DynamicProxyHandler(proxiedObject);
            return Proxy.newProxyInstance(
                proxiedObject.getClass().getClassLoader(),
                interfaces,
                handler
            );
        }
    
        private class DynamicProxyHandler implements InvocationHandler {
            private Object proxiedObject;
    
            public DynamicProxyHandler(Object proxiedObject) {
                this.proxiedObject = proxiedObject;
            }
    
            @Override
            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                long startTimestamp = System.currentTimeMillis();
    
                Object result = method.invoke(proxiedObject, args);
    
                long endTimestamp = System.currentTimeMillis();
                long responseTime = endTimestamp - startTimestamp;
                String apiName = proxiedObject.getClass().getName() + ":" + method.getName();
                RequestInfo requestInfo = new RequestInfo(apiName, responseTime, startTimestamp);
                metricsCollector.recordRequest(requestInfo);
    
                return result;
            }
        }
    }

    // MetricsCollectorProxy 클래스 사용 예예
    MetricsCollectorProxy proxy = new MetricsCollectorProxy();
    IUserController userController = (IUserController) proxy.createProxy(new UserController());
</code></pre>    
